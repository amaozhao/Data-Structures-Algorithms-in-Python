# 应用与分析

在这一章当中

- 分析问题
- 基础数据结构
- 特殊排序数据结构
- 排序
- 专业数据结构
- 外置储存
- 向前

我们简要总结了到目前为止所学的内容，着眼于决定在特定情况下使用哪种数据结构或算法。
本章附带一些注意事项。 必然，它是非常普遍的。 每个现实世界的情况都是独一无二的，所以我们在这里所说的可能不是你问题的正确答案。 你需要分析问题以确定其特征，并查看它们是否符合数据结构或算法的特征。
本章分为这些有些随意的部分：

- 分析问题：确定指导数据结构和算法选择的特征
- 基础数据结构：数组、链表、树、哈希表
- 特殊排序的数据结构：栈、队列、优先级队列、堆
- 排序：插入排序、Shellsort、快速排序、归并排序、堆排序
- 专业数据结构：四叉树、图
- 外部存储：顺序存储、索引文件、B 树、散列

> 笔记
> 有关这些主题的详细信息，请参阅本书的各个章节。

## 分析问题
作为开发人员，你应该始终查看你打算开发的软件的计划。 一个特定的软件项目可以有——而且通常有——许多目标。 商业公司想要创造销售的产品。 科学组织需要能够准确记录、建模和分析其数据的系统。 政府需要能够帮助教育、保护和解释其公民和司法管辖区的软件。 分析这些目标很重要； 它告诉你需要构建或更改的内容。 该组织的目标很少提供有关如何构建它以实现每个人都想要的速度、成本（在内存和其他计算资源方面）和易于维护的信息。
假设有人分析了总体目标并为新系统提供了一组所需的功能和要求。 要弄清楚哪些数据结构和算法是合适的，你需要查看所涉及的计算的特征。 什么样的数据正在被操纵？ 会处理多少？ 需要什么样的结果以及多快？ 这些问题的答案有助于缩小你的选择范围。

### 什么样的数据？

问题域通常非常清楚将要操作的数据类型。 它可能是关于公司交易的记录、动物叫声的录音、实验室实验的测量结果，或者将流式传输给观众的视频。 每种数据都是从原始数据类型构建的：数字、字符和布尔值。 基元被分组为有意义的块——例如，文本消息字符串、测量温度的数字数组、人员记录、道路中心线、医学图像和体积形状。 种类繁多的数据可能令人望而生畏。
尽管存在多样性，但一些特征有助于为数据结构选择最佳方法。 其中首先是如何访问数据的不同部分？ 例如，如果你正在处理文本消息字符串，你希望它们很短并且作为一个整体被请求； 可能不需要从每个文本中提取最后一个单词，也不需要在每个文本中找到中值字符。 通常，"块"作为一个整体进行操作。 如果块中的组件需要单独处理，则应注意这一事实。 例如，视频通常包含一系列静止图像和一个或多个音频通道的一系列单独的数值。 视觉和音频内容可以一起处理——就像编辑可能会分割采访视频一样——或者单独处理以查找单词的表达或查找视频帧中蓝天的外观。
识别出不同的数据块后，接下来要问的问题是如何识别这些数据块？ 特别是，是否有有助于唯一标识它的键或索引？ 例如，人事记录通常有很多字段，其中的几个字段可能被用作标识记录的键。 文本消息没有隐式密钥来识别它们，但当它们是记录的一部分时，它们通常有发件人、收件人和发送时间的密钥。 当然，可以处理文本内容以查找其他关键字，例如使用的单词、短语或语言。 键通常与更多数字结构（如数组或图像）一起存储。 例如，图像数据库可能具有与图像内容相关联的关键字，例如室外/室内、人物、风景、动物。
识别数据块的另一种方法是通过索引或坐标。 获取序列中的下一条消息意味着转到下一个索引。 要获取视频开始后 10 秒出现的图像，程序会通过索引找到视频帧。 类似数组的数据块总是有自然索引，并且经常被这些索引访问。 例如，将图像的每个像素存储在按像素值排序的二叉搜索树的不同节点中是没有意义的。 从树中重建图像的数组形式将非常耗时并且可能经常需要。 其他索引可能涉及多个数字，如地图坐标和体积/空间坐标。

### 多少数据？

当你知道数据的种类、它们如何放入块中以及如何处理它们时，下一个问题是这些块中有多少？ 这个特性通常会显着驱动数据结构的选择，有时是最难确定的。 对象通常从一个小范围开始，然后才有人尝试用大量数据运行它。 关注较小的尺寸很容易也很诱人，因为这意味着无论使用何种数据结构和算法，程序都可能运行得足够快。 通过多一点分析，你通常可以预见数据量可能会如何扩展并为此做好准备。
在分析中，你不必非常精确。 你实际上只需要知道数量级的数据项数量。 有几十个对象吗？ 几千？ 百万？ 确切的数字并不重要，但小数位数很重要。
寻找外部约束
如果要处理的数据以某种方式受到限制，你可能会得出这样的结论：代码永远不需要处理超过一定数量的数据。 例如，如果你知道系统只需要存储一个人的已知联系人，则极不可能需要存储超过 1,000 个对象，当然少于 100,000 个。 一个跟踪当今每个活着的人每人一两件物品的系统最多需要处理数百亿件物品。 到这样的系统需要处理数万亿的时候，很可能会有一些新系统取代它。

### 什么创建数据？

数据量的最大差异来自于它的产生方式。 如果数据是手动产生的，它很可能远小于自动化产生的数据。 人们手动制作的东西，如短信、歌曲或绘画，都受到从事这项活动所花费的时间和从事这项活动的人数的限制。 关于现在有多少人活着以及几十年后还会有多少人，有很好的模型。 可能不太清楚有多少人将执行该活动，但你实际上只需要估计数量级：数千、数百万等等。
自动化产生的数据可能大很多个数量级。 想象一下连续（或至少每晚）运行一年的天文望远镜产生的所有视频。 将其乘以所有运行中的望远镜和总时间段，以获得可能收集用于分析的数据量的估计值。 在进行估算时，你还必须考虑潜在的增长。 例如，当你考虑可能在视频共享网站上产生内容的视频来源的数量时，2000 年的估计可能比 2020 年之后的估计小一到两个数量级。 具有视频录制功能的手持智能手机得到广泛接受。
低估很常见。 对象通常从关注小目标开始，将扩展的挑战留到以后。 一个典型的例子是在 20 世纪后期开发的许多数据库系统中存储年份的两位数字的常见设计决策。 公司和政府在 2000 年之前努力寻找并修复所有这些有限的系统。类似的问题在未来也会出现，因为几乎所有的计时系统都使用固定数量的存储来存储它们的时间戳。 尽管这些例子并没有低估数据量，但它们表明了开发可以处理初始估计而不考虑数据随时间变化的系统的趋势。

### 什么操作和频率如何？

要构建的系统对这些数据块进行处理。 一个好的设计会列出所有操作，以及对它们完成频率的估计以及对其性能的要求。
例如，企业的簿记系统会为每笔销售交易、收入和付款插入新数据。 每天有数百或数千或（希望）数十万笔交易。 偶尔会有错误的删除，一天可能有一百个。 有一些操作可以报告每天、每周、每月、每季度和每年的总体活动、收入和支出。 其中每一项都有性能要求，例如能够在一微秒内插入新事务或在不到一分钟内获得季度报告。 所有这些都可以合理地实现，但是在一些新项目中，你可能会发现一些难以做到的问题。
对于人类的输入和输出，必须完成哪些类型的操作通常是非常清楚的。 为维护或发送到其他进程而完成的操作可能具有不太明确的时间限制。 例如，风暴预测模型需要定期使用最新输入重新运行，法律要求可能要求定期从系统中删除旧数据，并且需要在工作时间内处理流入速度太快而无法完全处理的金融交易。 在交易停止后进行核对和编目。 术语后台处理有时用于描述此类维护任务。 它们会影响所有系统的数据，因此可能会占用大量的计算资源。
当你考虑操作发生的频率时，并不总是可以具体说明。 与日、周、月、季、年报表的记账系统不同，大部分系统都是按需运行的，需求量变化很大。 然而，最重要的是要知道操作的相对频率。 搜索是否比插入更频繁？ 遍历是否比搜索更频繁？ 至少，你应该尝试对插入的四个基本操作进行排序，删除、搜索和遍历。
数据项的处理顺序强烈影响结构的选择。 例如，核对一个交易日内流入的所有交易可能必须按照它们发生的顺序进行。 这意味着队列比栈更合适。 如果流顺序与交易顺序不完全相同，那么优先队列或堆会更好。
在另一个示例中，仓库库存系统将更新添加到仓库的新库存和移除的对象以填写订单。 当用户想要下订单时，当前的商品数量决定了它是否可以立即完成。 订单中出现的对象的顺序是不可预测的。 订单包含看似随机的对象。 这意味着处理顺序是不可预测的，并且使用为特定顺序设计的数据结构（如队列或栈）可能是不明智的。
不同的算法也可以强加处理顺序要求。 在 Dijkstra 的图中两个顶点之间的最短路径算法（第 15 章，"加权图"）中，访问顶点有一个特定的顺序。 在汉诺塔问题（第 6 章，"递归"）中，移动圆盘的约束和寻找圆盘移动特定顺序的解题方法都需要后进先出 (LIFO) 处理顺序 由栈提供。 算法约束通常比系统要求提供的定义更好。
最重要的是，什么操作必须快？ 他们有什么特别的吗？ 如果系统的目的是生成送货卡车的行驶路线或查找附近仓库的位置，则通用数据结构的性能可能不够好。 必须最快执行的操作通常会强制选择使用专门的数据结构和/或算法。

### 谁来维护软件？

确定要使用的数据结构和算法不仅取决于数据和对数据的操作，还取决于在进行（不可避免的）更改时维护软件的人员。 程序员的技能水平各不相同，使用高度复杂的算法或结构可能会成为轻松进行更改的障碍。
了解谁将解决一个问题以及他们面临什么样的数据结构挑战可能是最难衡量的问题特征。 如果这是一个由大型企业或政府机构运行的程序，他们很可能能够找到高技能的程序员来维护和更新系统。 另一方面，由志愿者为社交俱乐部编写的程序可能难以找到更多志愿者来解决未来的某些问题。 与吸引具有软件技能的志愿者的组织相比，非技术组织可能会遇到更多麻烦。
如果你希望维护软件的人员能够熟悉高级数据结构，那么结构和算法的选择就非常开放了。 技术和科学组织通常很容易接受使用复杂的结构，如果它们能获得更好的性能的话。 换句话说，技术组织不太愿意冒险使用可能难以实现的高级结构和算法。
软件开发人员在以后的更新中掌握。 这并不意味着你应该始终为这样的组织选择最先进的结构或算法； 选择满足性能要求的最简单的一个意味着更多的开发人员将能够维护它。
当未来的开发人员定义不明确，或者不太可能熟悉高级结构，或者需要很长时间才能学习复杂的结构时，设计选择应该更加有限。 使用不广为人知的奇异算法会增加系统的维护负担。 也就是说，实现系统的性能要求始终很重要。 例如，如果系统无法在要求的时间内处理预期的数据量，则使用比复杂的 O(N×log N) 算法更容易理解的 O(N2) 算法是不可接受的。
请注意，使用标准库来实现数据结构可以减轻一些复杂性问题。 哈希表在它们的实现中使用了一些相当复杂的概念，但是当一个好的库可用时，或者当已经有一个高度优化的内置实现（如 Python 字典或集合）时，在另一个程序中使用它们很简单。 标准库中的数据结构具有文档齐全的编程接口和众所周知的性能特征，对于其他开发人员来说应该相当容易使用和维护。

## 基础数据结构
每个数据结构都建立在原始类型（数字、字符和布尔值）以及将它们组合在一起的方法之上。 将这些基元组织成更大的组的两种基本方法是将相同基元类型的序列放入数组，以及使用引用将不同的块链接在一起。 你也可以说引用是原始类型（尽管你仅使用它们来组织其他数据，而不是保存要操作的值）。
使用这些基本构造，你可以形成基础数据结构：数组、链表和树。 你还可以在此类别中包括哈希表。 哈希表在很多方面表现得像数组（尽管索引比数组复杂得多）。 所有其他结构都可以使用这些的组合来构建，但有时它们就是所需要的。
这些基础结构之间最大的区别是

- 它们包含的对象如何寻址：通过索引、通过引用、通过键、通过坐标
- 如何为它们分配和释放内存

当然，数组允许对象由整数索引，并分配在程序块中，在块中程序在创建数组时指定对象的数量。 链接列表和树使用引用。 它们包含的对象可以通过对链接或节点的引用来指定，或者可能通过从列表开头或树根计算对象的整数来指定。 链接和节点根据需要进行分配。 哈希表通过一个键来寻址对象，通常仅通过一个键。 当然，数组、链表和树中的对象也可以通过键来寻址，但是这样做需要更多时间，随着对象数量的增加，时间会显着增加。 哈希表在内存可以按需分配的方式上也有点像列表和树。
这些通用数据结构中的哪一个适合给定的问题？ 我们逐个分析它们，并展示问题的特征如何帮助回答这个问题。

### 速度和算法

通用数据结构在key指定item时，速度大致可以这样排列：数组和链表比较慢，树比较快，哈希表非常快。
然而，不要得出结论，使用最快的结构总是最好的。 使用它们会受到惩罚。 首先，它们在不同程度上比数组和链表更复杂。 此外，哈希表使用内存的效率有点低。 普通二叉树恢复到有序数据的慢 O(N) 操作； 平衡树避免了这个问题，但编程起来更复杂。

### 处理速度：移动目标

快速结构有一些缺点，另一个发展使慢速结构更具吸引力。 每年最新计算机的 CPU 和内存访问速度都会提高。 摩尔定律（戈登·摩尔于 1965 年提出）规定微芯片上的晶体管数量每 18 个月翻一番。 50 多年后，即使单个晶体管的尺寸接近分子和原子的尺寸，这种趋势仍然存在。
在一个相关的趋势中，芯片的时钟速度呈指数增长，尽管增长速度已经开始下降。 加上并行运行许多程序（或线程）的能力，计算机的有效处理速度持续呈指数级增长。 这不是说你不需要担心数据结构的大 O 效率吗？ 如果计算机的运行速度呈指数级增长，难道它不会克服较慢和较快结构之间的差异吗？
答案不是简单的是或否。 虽然计算机已经能够运行得更快，但软件开发人员已经利用这些优势来编写在计算机上使用更多内存和处理周期的软件。 这种软件膨胀意味着操作系统大小、随机存取存储器要求、库大小和功能都在增加。 具有讽刺意味的是，这些增长降低了硬件带来的速度提升，有时还会逆转。 实现"更易于使用"但速度较慢或内存密集度更高的结构的本能抵消了处理速度的提高。
假设几年前的一台计算机在可接受的时间内处理了 100 个对象的数组。 现在，计算机速度更快，因此包含 10,000 个对象的数组可能以相同的速度运行。 许多作者提供了在数据结构变得太慢之前可以创建的最大大小的估计值。 不要相信这些估计（包括本书中的估计）。 今天的估计不适用于明天。
相反，首先要考虑满足要求的最简单的数据结构。 除非很明显它们会太慢，否则编写一个简单版本的数组或链表，看看会发生什么。 如果它在可接受的时间内运行最大量的数据，那就别无所求。 如果你使用数组代替，没有人会注意到，为什么还要在平衡树上辛苦工作呢？ 即使你必须处理数百万或数千万的对象，看看数组或链表处理它们的能力仍然是值得的。 只有当实验表明它们的性能太慢时，你才应该恢复到更复杂的数据结构。 当然，如果你的初始设计没有成功，你必须适当地计划以便有时间进行此类更改。

### 库

所有主要编程语言的数据结构库都可以在市场上买到。 语言本身可能有一些内置的结构。我们在本书中广泛探索了 Python 的结构。 例如，Java 包括 Vector、Stack 和 Hashtable 类。 C++ 包括标准模板库 (STL)，其中包含许多数据结构和算法的类。
使用商业库可以消除或至少减少创建本书中描述的数据结构所需的编程。 它还消除了未来开发人员需要深入研究其编码细节的一些风险。 当商业或维护良好的公共图书馆可用时，使用平衡树等复杂结构或快速排序等精细算法将成为更有吸引力的可能性。 但是，你必须分析它们的特定功能、要求和限制，以确保类、方法或算法可以适应你的特定问题。

### 数组

在许多情况下，数组是存储和操作数据时应该考虑的第一种结构。 数组在以下情况下很有用

- 数据量相当小。
- 数据量是可以预先预测的。
- 在大多数情况下，这些对象将通过索引进行处理。
- 访问对象的顺序是可变的。

什么是"相当小"？ 答案取决于你的计算资源以及你必须为每个阵列单元存储多少数据。 基本思想是它应该适合计算机的随机存取存储器 (RAM)。 它可以与计算机允许的虚拟地址空间一样大，但该空间的一部分将被换入和换出随机存取存储器，从而减慢速度。 例如，单个处理器可能有 8 GB 的 RAM 和 264 字节的虚拟地址空间。 在那种环境下，分配一个十亿单元格数组（其中每个单元格占用 8 个字节）可能没问题。 数组越大，数据进出 RAM 的速度越快，计算速度就越慢。 在多个进程必须共享 RAM 的系统上，混洗变得更加明显。 我们将在"虚拟内存"部分详细讨论这个问题。
在许多应用程序中很难提前预测数据的大小。 当整个数组可以一次分配或可能在几次迭代中分配时，数组工作得最好。 当数组大小时，数据必须从现有数组复制到新数组。 增长操作有时会导致分配大量内存但未使用。
数组的速度取决于能否在常数时间内找到一个单元格，方法是使用整数索引找到它在内存中相对于数组起始地址的位置。 如果使用数组中对象的算法具有可用的整数索引，则数组会尽可能快。 如果对象必须在数组中移动，比如在排序数组或活动数据必须始终是前 N 个单元格的数组中，那么索引会随着删除和/或插入而改变，并且变得更难利用 恒定时间访问。 当数据将被插入、由索引随机访问并且很少被删除时，数组是最好的。
你不应该使用数组

- 如果数据将通过键寻址（尝试哈希表）。
- 如果有很多插入和/或删除需要在数组中移动对象。
- 如果数据必须按排序顺序保存并且很大（尝试堆）。

### 链表

考虑链表时

- 要存储的数据量不容易提前预测，因此尽量减少内存使用量很重要。
- 数据会频繁插入和删除，项的顺序很重要。
- 数据将按照接收到的顺序（或相反）处理或处理。

链表在添加新项时获得所需的任何存储空间，因此它可以扩展以填充所有可用内存； 并且不需要像数组那样在删除过程中填补"漏洞"。
在无序列表中插入速度很快。 按键或按索引搜索和删除很慢（尽管删除比在数组中快）。 与数组一样，当数据量相对较小时，最好使用键或索引寻址的链表。
你不应该使用链表

- 如果数据将由键寻址（尝试哈希表）。
- 如果数据将由整数索引以任意顺序寻址（尝试数组）。

### 二叉搜索树

当数组和链表被证明太慢时，二叉搜索树是下一个要考虑的结构。 考虑二叉搜索树

- 何时数据将由一个键寻址和排序。
- 当数据会被频繁插入和删除时。
- 当最小化内存使用很重要时。

树提供快速的 O(log N) 插入、搜索和删除。 按键顺序遍历是 O(N)，这对于任何数据结构来说都是最快的。 [事实上，二叉搜索树通过键对它们的对象进行排序意味着按排序顺序遍历需要 O(N) 时间，而未排序的数组或列表需要首先排序。]你还可以快速找到最小值和最大值，O (log N)，并遍历一系列对象。
一棵不平衡的二叉树比自身平衡的二叉树更容易编程，但不幸的是，有序数据会将其性能降低到 O(N) 时间，并不比链表好。 如果你确定数据将以相对于密钥的随机顺序插入，那么使用平衡树就没有多大意义。
你不应该使用二叉搜索树

- 如果数组或链表满足所有要求。
- 如果对象的顺序不重要。
- 如果对象很可能以密钥的正向或反向顺序插入。

### 平衡搜索树

在各种平衡搜索树中，我们讨论了 2-3-4、红黑和 AVL 树。 它们都是平衡树，因此无论插入是否根据键排序，都能保证 O(log N) 的性能。 这些平衡树很难编程。 它们还可能比普通的二叉搜索树强加更多的内存开销，这可能会或可能不会很重要。
考虑平衡搜索树

- 何时数据将由一个键寻址和排序。
- 当很可能以键的（反向）顺序插入长序列时。
- 当数据会被频繁插入和删除时。
- 当最小化内存使用很重要时。
- 当平衡算法的复杂性由经验丰富的开发人员处理时。

使用由合格公司或其他组织维护的库可以降低与开发和维护复杂算法相关的风险。 在许多情况下，哈希表可能是比平衡搜索树更好的选择，但也可能使用复杂的哈希算法。
你不应该使用平衡搜索树

- 如果数组或链表满足所有要求。
- 如果对象的顺序不重要。
- 如果对象可能相对于密钥以随机顺序插入。

### 哈希表

哈希表对于几乎所有由一个键引用的数据项都具有最理想的性能。 键可以是任何可能被视为索引的数据类型，包括整数。 键搜索、插入和删除的 O(1) 性能是最快的。
考虑一个哈希表

- 当数据将由键寻址并且键对对象的遍历顺序不重要时。
- 当最小化内存使用量有些重要时，一些未使用的内存是可以容忍的。
- 当散列和冲突解决算法的复杂性由经验丰富的开发人员处理时。

哈希表对数据插入的顺序不敏感，因此可以代替平衡树。 假设一个好的密钥散列函数可用，对它们进行编程比平衡树更简单。
哈希表需要的内存量超过最小内存量，尤其是对于开放式寻址。 例如，负载因子限制为 50%，它们使用的单元格数量是链表所需的两倍或更多。 与链表和树一样，内存可以在插入对象时分配，只需少量的额外时间。 （有些插入会导致数组增长，有些删除会导致数组缩小，但在 N 次操作中，复制对象只需要与 N 成比例的时间。）
哈希表不支持任何类型的有序遍历，也不支持轻松访问最小或最大键和项。 即使找到所有已插入的键，也比树或列表更耗时。 如果这些能力很重要，二叉搜索树是更好的选择。
你不应该使用哈希表

- 如果按键的对象顺序很重要（尝试平衡搜索树）。
- 使用的内存量必须尽可能小（尝试平衡搜索树）。
- 对象的键没有被散列函数统一散列（尝试另一个散列函数）。

比较通用存储结构

表 16-1 总结了使用大 O 表示法的各种基础数据存储结构的速度。
表 16-1 基础数据结构速度

| 数据结构                 | 搜索     | 插入     | 删除     | 遍历                 |
| ------------------------ | -------- | -------- | -------- | -------------------- |
| 数组                     | O(N)     | O(1)     | O(N)     | O(N)*                |
| 有序数组                 | O(log N) | O(N)     | O(N)     | O(N)                 |
| 链表                     | O(N)     | O(1)     | O(N)     | O(N)*                |
| 有序链表                 | O(N)     | O(N)     | O(N)     | O(N)                 |
| 二叉树（平均）           | O(log N) | O(log N) | O(log N) | O(N)                 |
| 二叉树（最坏情况）       | O(N)     | O(N)     | O(N)     | O(N)                 |
| 平衡树（平均和最坏情况） | O(log N) | O(log N) | O(log N) | O(N)                 |
| 哈希表                   | O(1)     | O(1)     | O(1)     | O(N)* (but higher C) |

在无序数组和列表中，插入分别在结构的末尾和开头进行。 数组中的删除需要通过移动对象来填补空白。 删除列表的第一项是 O(1)，但一般的按键删除需要 O(N)。 有序数组使用二分查找，速度快，但是插入和删除平均需要移动一半的元素，速度慢。 遍历意味着访问所有 N 项，但只有有序结构才能轻松按升序（或降序）键的顺序访问它们； 星号 (*) 表示不支持按有序键遍历。

### 特殊排序数据结构

本书讨论的特殊排序数据结构是栈、队列和优先级队列。 这些结构提供了对特定顺序的数据的快速访问。 它们不是用作通用数据存储，而是通常由计算机程序用来帮助执行某些算法。 我们在本书中看到了这种用法的示例，例如第 14 章"图"和第 15 章"加权图"，其中栈、队列、优先级队列和哈希表都用在图算法中。
栈、队列和优先级队列由基本结构实现，例如数组、链表或（在优先级队列的情况下）堆。 这些数据结构为用户提供了一个简单的界面，通常只允许插入和访问或删除一个特定数据项的能力。 这些无障碍对象是

- 对于栈：最后插入的对象
- 对于队列：插入的第一个对象
- 对于优先级队列：具有最高优先级的对象（以及具有相同优先级的对象中的第一个对象）

这些抽象数据类型 (ADT) 可以看作是概念上的辅助工具。 它们的功能可以直接使用底层结构（例如数组）获得，但是定义良好的接口使任何程序员都清楚它们的目的是提供按特定顺序的快速访问。 例如，想象两个相似的程序，一个有一个数组（Python 中的列表），另一个有一个队列对象。 它们可能对底层单元执行完全相同的操作，但队列的存在表明数据将按先进先出 (FIFO) 顺序处理。
这些 ADT 的主要缺点是无法通过键值方便地搜索对象。 它们可以很容易地遍历，但只有优先级队列可以按键顺序快速遍历（如果它没有实现为堆）。

### 栈

当你只想访问最后插入的数据项时，使用栈； 只有在对最后一个数据项执行某些操作后才能访问其他项。 这是一种后进先出 (LIFO) 结构。 它还允许快速查看插入栈中的第一个对象，但不能删除它。
栈通常实现为数组或链表。 数组实现是高效的，因为最近插入的对象放在数组的末尾，也很容易删除。 栈溢出可能会发生，但如果数组的大小足够大则不太可能发生。
如果栈将包含大量数据并且无法提前准确预测数量（如将递归实现为栈时），链表是比数组更好的选择。 链表是高效的，因为可以从列表的头部快速插入和删除对象。 直到整个内存已满，才会发生栈溢出。
用链表实现栈比用数组稍慢，因为每次插入都需要分配内存来创建新链接，而不是在开始时分配所有需要的空间。 在从列表中删除对象后的某个时候，需要重新分配链接。 这可能由程序或通过称为垃圾收集的过程显式完成（两者都需要时间）。 链表实现可以比数组实现更高或更低的内存效率。 链表需要存储指向下一个链接的指针，而如果栈大小远小于分配的大小，则数组可能有许多未使用的单元格。

### 队列

当你只想访问插入的第一个数据项时使用队列； 它是先进先出 (FIFO) 结构。
与栈一样，队列可以实现为数组或链表。 两者都是高效的 O(1) 插入和删除。 该数组需要额外的编程来处理队列在循环数组末尾环绕的情况。 链表必须是双端的，以允许在一端插入和在另一端删除。 数组和双端链表实现也允许 O(1) 访问查看最后插入的对象但不能删除它。
与栈一样，数组实现和链表实现之间的选择取决于最大对象数的预测程度。 如果你知道会有多少数据，请使用数组； 否则，使用链表。

#### 优先队列

当唯一需要访问的是具有最高优先级的数据项时，使用优先级队列。 这是具有最大（有时是最小）键的对象。
优先级队列可以实现为有序数组或堆。 插入有序数组很慢，但删除很快。 对于堆实现，插入和删除都需要 O(log N) 时间。 堆实现的缺点是它不保留具有相同键的对象之间的 FIFO 排序（不包括插入时间作为优先键的一部分）。
堆实现几乎总是比作为有序数组实现更快。 这些类型的内存使用情况各不相同，但始终为 O(N)。 如果可以预先预测最大对象数，则排序后的数组需要的内存最少。 如果大小难以预测，有序数组和堆都可以根据需要增长，而不会降低整体插入时间，但代价是有更多未使用的内存。
如果需要对等键对象进行 FIFO 排序，请使用有序数组，并且很难根据插入时间可靠地确定对象的优先级。 对于所有其他优先级队列，堆是最好的选择。

### 特殊排序结构的比较

表16-2显示了栈、队列、优先级队列的插入和删除的大O时间，以及是否可以在O(N)时间内按照key的顺序遍历。 这些结构不支持快速搜索。
表 16-2 特殊排序数据结构速度

| 数据结构                       | 插入     | 删除     | 按键顺序遍历 | 评论                      |
| ------------------------------ | -------- | -------- | ------------ | ------------------------- |
| Stack (array or linked list)   | O(1)     | O(1)     | No           | 删除最后插入的对象 (LIFO) |
| Queue (array or linked list)   | O(1)     | O(1)     | No           | 删除最先插入的对象 (FIFO) |
| Priority queue (ordered array) | O(N)     | O(1)     | Yes          | 删除最高优先级的对象      |
| Priority queue (heap)          | O(log N) | O(log N) | No           | 删除最高优先级的对象      |

## 排序
具有良好排序能力的图书馆的广泛使用使得编写排序方法变得稀有。 第一步，寻找经过良好测试的库并在问题数据上进行尝试。 如果你找不到性能足够好的一个，你可能需要实施自己的。
对于适合内存的数据，最初尝试一种缓慢但简单的排序是值得的，例如插入排序。 你的计算平台可能有足够的处理速度来在合理的时间内对数据进行排序。 请记住尝试使用许多不同的数据初始排序，因为插入排序（和其他算法）的性能可能会随着输入排序而显着变化。
插入排序是我们在第 3 章"简单排序"中看到的最好的简单排序算法，并且特别适用于几乎已排序的数据，如果没有太多对象错位，则操作时间大约为 O(N)。 例如，当向一个已排序的 2000 万的文件中添加 10 个对象时，插入排序应该非常快。
如果插入排序证明太慢，那么你可能需要 O(N×log N) 算法，就像我们在第 7 章"高级排序"中介绍的那样。 这些可能要复杂得多，因此使用像插入排序这样简单但缓慢的算法有利于测试下一个方法的正确性。
接下来你可以试试 Shellsort。 它的实现相当简单，应该可以达到 O(N^3/2^) 的性能。 你需要实现一个区间序列，Knuth 的可能没问题。
如果 Shellsort 证明太慢，你应该使用一种更复杂但速度更快的排序：mergesort、heapsort 或 quicksort。 Mergesort 需要额外的内存，如果数据不适合内存，这是最好的选择。 当没有足够的 RAM 时，可以通过一次从两个排序的文件中读取一个对象并将最低的对象输出到第三个文件来完成合并。 文件合并通常与内存排序方法（如 Shellsort 或堆排序）配对，以对初始文件数据的一小部分进行排序并将它们写入磁盘
对于内存中排序，第 13 章"堆"中描述的堆排序具有明显的优势。 数据可以在初始数组中排序，而不需要额外的内存。 无论初始数据排序如何，它都会在 O(N×log N) 时间内对数据进行排序。 一个附带的好处是，用于将初始数组制成堆的 heapify 方法可用于在 O(N) 时间内制成堆，从而无需全排序即可实现订单统计等计算。 heapsort 的缺点是它的算法有点复杂，最终比 quicksort 进行更多的比较，尽管两者总体上都是 O(N×log N)。
如果复杂的算法不是一个威慑力，Timsort 也是一个选择。 虽然 Timsort 的平均性能也是 O(N×log N)，但它的额外好处是可以在 O(N) 时间内运行初始排序的数据。
表 16-3 总结了排序算法的运行时间。 标有算法复杂性的列试图对理解和正确实现算法的难度级别进行分类。 当然，这在很大程度上取决于执行实现的程序员。 对某些人来说简单的事情对其他人来说可能很复杂。
表 16-3 排序算法速度比较

| Sort      | 最好       | 平均       | 最差       | 算法复杂度 | 额外内存 |
| --------- | ---------- | ---------- | ---------- | ---------- | -------- |
| Bubble    | O(N^2^)    | O(N^2^)    | O(N^2^)    | 简单       | No       |
| Selection | O(N^2^)    | O(N^2^)    | O(N^2^)    | 简单       | No       |
| Insertion | O(N)       | O(N^2^)    | O(N^2^)    | 简单       | No       |
| Shellsort | O(N^3/2^)  | O(N^3/2^)  | O(N^3/2^)  | 中等       | No       |
| Quicksort | O(N×log N) | O(N×log N) | O(N^2^)    | 难         | No       |
| Mergesort | O(N×log N) | O(N×log N) | O(N×log N) | 中等       | Yes      |
| Heapsort  | O(N×log N) | O(N×log N) | O(N×log N) | 难         | No       |
| Timsort   | O(N)       | O(N×log N) | O(N×log N) | 高难       | Yes      |

## 专业数据结构
许多数据结构被创建来解决特定的问题领域。 它们可以很好地实现其设计目标，但不能真正用作通用数据存储。 尽管它们可能支持对象的插入、删除、搜索和遍历，但它们的主要操作不同。 你可以根据需要的操作转向这些结构。

### 四叉树和网格

当数据项具有空间组件时，位于二维空间（如地图）或三维空间中，你需要能够快速搜索这些空间的结构。 四叉树和网格提供了一种捕获点或区域空间信息的方法，以便可以在二维空间中按位置找到对象。 八叉树为三维空间中的对象提供了类似的结构。
通过按坐标组织对象，四叉树可以快速搜索最接近给定点的对象或在给定点的特定半径内的对象。 与二叉树类似，这些类型的搜索（加上插入和删除）可以在 O(log N) 时间内完成。 当有大量点聚集在几个区域时，这比简单的点列表或网格要快得多。
对于较小的点集合，网格可以很好地执行。 当点在已知范围内接近均匀分布时，它们可以胜过四叉树。

### 图

图可用于模拟现实世界的情况。 图的结构反映了交通和通信网络等问题的结构。 它们还用于其他算法，例如 PageRank 算法——Google 搜索结果的初始排名机制。 网站的互连结构可以用有向图建模。
当你需要图表时，没有别的办法了，因此无需决定何时使用图表。 主要选择是如何表示图形：使用邻接矩阵或邻接列表。 你的选择取决于图形是稠密的（何时首选邻接矩阵）还是稀疏的（何时应使用邻接列表或邻接哈希表）。
图处理的特殊操作包括查找路径、树和子图。 对于邻接矩阵表示，针对特定顶点或某种顶点的深度优先搜索和广度优先搜索在 O(V^2^) 时间内运行，其中 V 是顶点数。 对于邻接表表示，它们在 O(V+E) 时间内运行，其中 E 是边数。 使用邻接矩阵查找最小生成树和最短路径运行时间为 O(V^2^)，使用邻接列表运行时间为 O((E+V)×log V)。 在稠密图中，边的数量可以是 V^2^ 的数量级，因此你需要为你的图估计 V 和 E 并进行算术运算以查看哪种表示是合适的。

## 外置储存
对于大多数数据存储结构，我们假设数据保存在主内存中。 当数据太大，内存放不下时，就必须将部分或全部数据存储在外部存储器中，这通常是指磁盘文件。 我们在第 9 章"2-3-4 树和外部存储"的第二部分和第 11 章"哈希表"中讨论了外部存储。
当数据存储在磁盘文件中时，我们假设它以称为块的固定大小单元组织，每个块包含一定数量的记录。 磁盘文件中的记录与主存中的对象保存相同类型的数据。 与对象一样，记录至少有一个用于访问它的键值。
我们还假设读取和写入操作总是涉及单个块，并且这些读取和写入操作比主存储器中的任何数据处理更耗时。 为了快速操作，必须尽量减少磁盘访问次数。

### 顺序存储

最简单的外部存储方法是随机存储记录，并在搜索具有特定键的记录时顺序读取它们。 新记录可以简单地插入到文件的末尾。 已删除的记录可以标记为已删除，或者记录可以向下移动（如在数组中）以填补空白。
平均而言，查找和删除需要读取一半的块，因此顺序存储不是很快，操作时间为 O(N)，其中 N 为块数。 尽管如此，对于少量记录来说，它可能还是令人满意的。

### 索引文件

使用索引文件时，速度会显着提高。 在这个方案中，键的索引和相应的块号保存在主内存中。 要访问具有指定键的记录，请查询索引。 它为密钥提供块号，只需要读取一个块，花费 O(1) 时间。
可以使用具有不同类型键的多个索引（一个用于姓氏，一个用于电话号码，等等）。 在索引变得太大而无法放入内存之前，此方案运行良好。 在这种情况下，索引文件本身存储在磁盘上并在需要时读入内存。
索引文件相对于顺序存储的缺点是必须创建和维护索引。 此过程涉及按顺序读取所有记录，因此创建索引可能会很慢，如果它是在存储了许多外部记录之后创建的。 此外，在文件中插入和删除对象时需要更新索引。

### B树

B-树是多路树，常用于外部存储，其中节点对应磁盘上的块。 与其他树一样，算法沿着树向下寻找路径，在每一层读取一个块。 B 树在 O(log N) 时间内提供记录的搜索、插入和删除。 这非常快，甚至适用于非常大的文件。 然而，编程并不简单。

### 哈希

如果使用大约两倍于文件通常占用的外部存储空间是可以接受的，那么外部散列可能是一个不错的选择。 它具有与索引文件相同的访问时间 O(1)，但可以处理更大的文件。

### 选择外部存储类型

选择何种方案来管理外部存储取决于问题的特点。 如果必须维护记录的多个索引（例如，按姓名、电话、地址），使用索引文件确实是唯一的选择。 由于必须为每个操作更新多个索引，因此此选项对于插入和删除操作需要更长的时间，但它为使用一个或多个索引的搜索提供了最快的访问。
如果只需要一个索引，那么 B 树或哈希就变得很有吸引力。 B 树使用较少的磁盘空间，散列提供最快的搜索访问。

### 虚拟内存

有时你可以让你的操作系统的虚拟内存功能解决磁盘访问问题，而你只需进行很少的编程工作。
如果你跳过 B 树或散列的复杂性并简单地使用顺序存储，你可以将大型磁盘文件读取到一个数组中。 如果该数组太大而无法放入主（RAM）内存，则虚拟内存系统会将该数组的一部分保留在主内存中，并将其余部分存储在磁盘上。 当你访问阵列的不同部分时，它们会自动从磁盘读取并放入内存中。 这通常在称为页面的内存块中完成。
你可以通过假设相应的数组同时在内存中，将内部算法应用于整个文件内容，并让操作系统担心读取文件的适当部分（如果它不在内存中）。 操作系统有一些复杂的方法来预测接下来需要哪些内存页面并确保它们被快速加载。
当然，在这么大的数组上操作，比整个数组都在内存中要慢，但是改变你的算法，使用B树或散列来查找记录也需要时间。 目前还不清楚哪个更快，虚拟内存分页很可能比其中一种外部存储算法更快或更慢，具体取决于数据量。 考虑到这种不确定性，可能值得简单地忽略文件不适合内存这一事实，并看看你的算法在虚拟内存的帮助下工作得如何。 如果简单的实现效果不够好，那么你可以花时间优化外部存储器访问。

## 向前

我们已经结束了对数据结构和算法的调查。 这个主题庞大而复杂，没有一本书可以让你成为专家。 我们希望这本书能让你对它们有所了解并教会你基础知识。 如果你对这种品味感兴趣，还有更多的数据结构和此处描述的变体等着你。 一些研究人员将他们的整个职业生涯都花在发明、开发和分析他们的表现上。 我们这些简单地将它们用作构建块的人通过解释这些分析并将它们与我们的工作要求进行比较而受益。
附录 B，"进一步阅读"包含进一步研究的建议。