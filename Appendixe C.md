# 问题的答案
在本附录 C

- 第 1 章 概述
- 第 2 章 数组
- 第 3 章 简单排序
- 第 4 章 栈和队列
- 第 5 章 链表
- 第 6 章 递归
- 第 7 章 高级排序
- 第 8 章 二叉树
- 第 9 章 2-3-4 树和外部存储
- 第 10 章 AVL 和红黑树
- 第 11 章 哈希表
- 第 12 章 空间数据结构
- 第 13 章 堆
- 14 章 图形
- 第 15 章 加权图

**索引**
  第 1 章 概述

  第 2 章 数组

  第 3 章 简单排序

  第 4 章 栈和队列

  第 5 章 链表

  第 6 章 递归

  第 7 章 高级排序

  第 8 章 二叉树

  第 9 章 2-3-4 树和外部存储

  第 10 章 AVL 和红黑树

  第 11 章 哈希表

  第 12 章 空间数据结构

  第 13 章 堆

  第 14 章 图形

  第 15 章 加权图

## 第 1 章 概述
1. 插入、查找、删除、遍历
2. c
3. 如果它在类定义下方缩进，而在外部（未缩进）级别没有中间定义。
4. 排序
5. 构造函数是构建对象类实例的函数。 Python 使用类的 \_\_init\_\_() 方法作为构造函数。
6. 你选择数据结构来模拟程序所代表的系统和行为。 在对系统建模同样出色的数据结构中，你可以选择执行效率最高的数据结构。 在那些执行速度相同的程序中，你可以选择占用内存空间最少的程序。
7. 关键字字段用于查找更大的记录，通常通过保持关键字的排序结构来加速搜索。
8. 它可以减少存储数据所需的内存量。 它使程序更容易理解，因此也更容易被其他程序员维护。
9. 实现数据结构并用它们操作的数据紧密组织算法。
10. b、d 和 g

## 第 2 章 数组
1. 他们应该有 get() 和 set() 方法来访问特定数组单元格的值。 获取和设置由整数值索引的单元格的能力是所有语言中数组的基本功能。
1. d. 有些语言不需要在构造时指定最大单元格数，但大多数语言都需要。
1. 防止访问对象实例的内部值被对象外部的代码操纵。
1. d
1. 真实
1. b
1. 错误
1. d
1. a
1. 两个 find() 方法都返回一个数字索引到有序数组中包含要查找的项目的单元格。 如果要查找的项目不在数组中，则 find() 会返回查找项目之后的下一个项目的索引（如果有）。 两种 search() 方法都返回存储在 find() 发现的数组索引处的项目，如果找不到项目或键，则返回 None 。 OrderedRecordArray.py 中的版本按键搜索而不是项目本身。
1. 升为幂
1. 3
1. b
1. 6
1. 错误
1. a
1. 常量
1. c
1. b
1. 当前基于太阳系的实施中的记录数量为数十条，甚至数百条记录。 对于可能需要以“随机”顺序访问的数十亿条记录，需要一种比 O(N) 更快的搜索方法。 要获得 O(log N) 搜索速度，至少需要一个有序数组。 事实上，需要更复杂的数据结构才能将搜索时间缩短到合理的水平。 单个记录的大小在这里不是重要因素。

## 第 3 章 简单排序
1. d
2. 比较和交换（或复制/移动）
3. 错误
4. a
5. 错误
6. b
7. 错误
8. 假设没有并发复制，交换将比复制操作花费三倍的时间，因为交换涉及三个独立的复制操作。
9. 对索引小于或等于外部的项目进行排序。
10. c
11. d
12. 副本
13. b
14. 索引小于外部的项目被部分排序。
15. b

实验 3-A：冒泡排序和插入排序算法是稳定的。 选择排序不稳定。 例如，列表 [('elm', 1), ('elm', 2), ('asp', 1)] 排序为 [('asp', 1), ('elm', 2), ( 'elm', 1)] 按第一个元素排序时。

## 第 4 章 栈和队列
1. 10
1. b
1. 后进先出和先进先出
1. 错误
1. 都没有； 它不动。
1. 45
1. 错误
1. c
1. O(N)
1. c
1. 是的
1. b
1. 是的。 需要修改 find() 方法以找到数组中插入项优先级的最低索引（假设高索引位于队列的前面且优先级最高）。 这是维护具有相同优先级的项目的 FIFO 顺序所必需的。 find() 方法中的二分搜索算法在找到具有匹配优先级键的第一个索引处停止。
1. a（如果某些击键可以具有更高的优先级并且需要在队列中先于其他击键进行处理，则可能是 b）
1. a

## 第 5 章 链表
1. c
2. first（在LinkedList中称为__first）
3. d
4. 2
5. 1 加上在新链接中将 \_\_next 字段设置为 None，这实际上是一个非引用。
6. b
7. x.setNext(无)
8. 当变量 x 作为引用而不是其值的副本传递时
9. a
10. c
11. 链表
12. a
13. 双端列表
14. 有序的双端列表
15. d
16. 通常，列表。 它们都在 O(1) 时间内执行 push() 和 pop()，但列表更有效地使用内存。
17. 阵列。 二分搜索允许 O(log N) 时间来按键查找项目，但是如果你使用列表，即使是双向链接的列表，每个搜索步骤都必须遍历所有中间链接才能到达下一个要测试的项目。
18. b
19. 调用程序可以改变链接的下一个指针来创建或中断循环列表，无论列表类型是否支持它们。
20. a

## 第 6 章 递归
1. c
2. 101
3. d
4. 2 base case返回0，nth在base case的调用者中的值为1。 该调用者返回第一个非基本情况值 1。返回 1 之后的 nth 的值在调用中，其中 nth 的值为 2。
5. 真实
6. 对
7. c
8. 移动较少数量的磁盘并重新分配每个主轴的角色
9. b
10. b
11. b
12. 11  堆栈中的某一点对数组大小为 1,024、512、256、128、64、32、16、8、4、2 和 1 的 mergesort() 有调用。
13. 栈
14. 递归执行中发生的每次调用都必须存储递归函数的函数参数和局部变量。 这些可以存储在问题描述中并保存在堆栈中。
15. 问题描述栈为空时

## 第 7 章 高级排序
1. c
2. 40
3. d
4. 复杂度可能退化为 O(N^2^)。
5. O(N×log N), O(N^2^)
6. a
7. 枢轴
8. d
9. 是的
10. c
11. 递归地划分结果子数组（对数组进行完全排序）
12. b
13. 枢轴
14. log~2~N
15. 对于最初正向或反向排序的数据，复杂度变为O(N^2^)。
16. 是的
17. a
18. O(N)。 它需要 10 个链表，这些链表必须共同存储 N 个元素的完整副本。
19. d
20. b 而已，它是 mergesort 的修改版本。

## 第 8 章 二叉树
1. O(log N)
2. c
3. 错误
4. b
5. 5
6. c
7. 节点，（二分查找）树
8. a
9. d
10. 错误
11. 发现
12. b
13. 链表
14. A的key，A的右子节点的key
15. d
16. d
17. 2×n+2
18. 错误
19. 压缩
20. c

## 第 9 章 2-3-4 树和外部存储
1. b
2. 身高较低； 总是平衡的
3. 2
4. 错误
5. b
6. 根分裂
7. a
8. 2
9. b
10. O（日志N）
11. d
12. 一个街区的价值
13. 2-3
14. a

15.c

## 第 10 章 AVL 和红黑树

1. 按键的顺序（或倒序）
2. b
3. c
4. c
5. a
6. b
7. 错误
8. d
9. b
10. 旋转，改变节点的颜色（交换和翻转）
11. 红色
12. 左子节点，右子节点
13. d
14. 一个节点（黑色），它的两个子节点（红色）
15. b
16. 是的
17. a
18. d。 插入时带有两个红色子节点的黑色节点只需要一次颜色交换。
19. d
20. d

## 第 11 章 哈希表
1. O(1)
1. 哈希函数
1. 模运算
1. 碰撞
1. d
1. 线性探测
1. (0), 1, 4, 9, 16, 25
1. b
1. a
1. 链表或二叉搜索树
1. 1.0
1. 是的
1. 成为质数
1. 数组大小
1. 所有这些； 对于同一个键，不成功的搜索必须遍历整个探测序列，而成功的搜索会在找到的项目处停止。
1. b
1. b
1. 一个排序的链表是最有效的，所有 N 项都有一个空链接。 其次最有效的是负载因子为 0.6 的哈希表，它有 0.4 × N 个空单元格或删除单元格。 AVL 树的所有叶子节点都有两个空链接，最多为 (N + 1)/2，而叶子节点的某些父节点有一个空链接。 对于一个完整的、平衡的二叉树，将恰好有 (N + 1)/2 个叶节点，并且内部节点之间没有空链接。 总体而言，总数将接近 2 × N/2 或 N 个空单元格。 特定树中的实际计数可能与此不同，但不会低于 N/2，这仍然超过 0.4 × N。
1. 错误
1. 同一个街区

## 第 12 章 空间数据结构

1. 键是两个数字的组合，而不是单个整数或字符串。
2. 地理或经纬度
3. 距离函数（以及存储点的独立结构）
4. b
5. 错误
6. 每个网格单元只存储一部分空间数据，减少搜索时间
7. 四叉树可以适应空间数据中的集群，而网格单元格最终可能会出现一些单元格非常满而另一些单元格为空的情况。 对于网格和点列表，它们的搜索时间为 O(log N) 而不是 O(N)。
8. d
9. 
   1. O(N)
   2. O(N)
   3. O(log N)

10. 错误
11. d
12. 错误
13. 象限是围绕节点中心的东北、西北、西南和东南区域。 位于两个象限边界上的点按顺时针顺序放置在下一个象限中。
14. d
15. 错误

## 第 13 章 堆
1. b
2. 左右子项都有小于（或等于）父项的键，但子项之间没有指定顺序。
3. 根
4. d
5. a
6. c
7. 数组或链表
8. 向下筛选，因为它必须确定最大子密钥
9. b
10. a
11. O(N×log N)
12. 较慢，因为每个项目需要更多时间，但在某些情况下更快，因为它不会退化为 O(N^2^)
13. c
14. ñ
15. N+K×logN

实验 13-B：堆排序算法不稳定。 考虑一个所有相等键的数组，例如 2, 2, 2, 2, 2, 2。它已经满足堆条件，因此 heapify 不会重新排序任何项目。 最大（根）项从堆中删除并转到数组的最后一个位置。 然后将堆中剩余的最后一个等键项移动到根并向下筛选。 因为堆中的所有键都是相等的，所以该项目不会向下筛选并成为移动到末尾的下一个项目。 这对所有相同键控的项目重复，将最后一个交换为第一个，然后在每次删除时再次将它们交换回来。 使用六元素数组的原始索引——0、1、2、3、4 和 5 来跟踪项目顺序——最终排列将是 1、2、3、4、5、0。

## 第 14 章 图形

1. 边、顶点（有时是节点）
1. 统计1或边的个数除以2（假设恒等对角线全为0）。
1. 顶点、边
1. d
1. A：B，B：A➔C➔D，C：B，D：B➔C
1. a
1. 三。 如果顶点是 A、B 和 C，则最小生成树由路径 ABC、BCA 和 CAB 定义。
1. 选项 b，深度优先搜索，是最快的，因为它需要 O(N^26) 的时间。 选项 a 首先使用深度优先遍历整个连通分量来找到 MST，然后花费更多时间来查找 Z 是否在 MST 中。 选项 c 在 O(N^2^) 时间内运行但不适用于所有有向图，因为如果存在包含 A 和 Z 的循环，广度优先搜索将仅在同一组件中找到 A 和 Z。选项 d 有效但需要 O (N^3^) 计算连接矩阵的时间。
1. c
1. 有向无环图（DAG）或树（有向或无向）
1. b
1. 没有
1. 是的
1. d
1. 是的。 邻接矩阵是不对称的，因此该图是无向的。 结果将是一个异常，因为图形包含一个循环 ABDA。
1. 有向无环图
1. b
1. 仅当目标是找到没有边的顶点时。 每个具有无向边的顶点都有一个前驱。 结果将找到所有没有边的顶点，其余顶点基本上形成一个循环（如果允许像 ABA 这样的循环用于无向边 AB）。
1. 使用改进的拓扑排序算法，计算时间为O(N^2^)。 因为第一个图的顶点数是原来的 10 倍，所以比率为 10^2^ = 100。基本拓扑搜索的时间复杂度为 O(N^3^)，因此比率为 10^3^ = 1,000。
1. 本章提到的算法都没有解决柯尼斯堡桥问题。

## 第 15 章 加权图
1. 距离、成本、时间
1. c
1. d
1. False（对于无向图）
1. 最低权重边
1. b

7. 错误
7. 已经在MST中
7. 错误
7. a
7. 是的
7. a
7. d
7. 在 Warshall 算法中，连接矩阵单元使用按位或规则更新，而在 Floyd-Warshall 算法中，单元使用当前值的最小值和添加两个其他单元值的最小值更新。
7. 顽固
7. 邻接表、邻接矩阵
7. 弗洛伊德-沃歇尔
7. 2^N^，其中N为K^2^-1，棋盘上的方格数-1
7. 不是。文中“旅行商问题”部分提到的路线总成本为 140，而建议的路线成本为 145。TSP 的最小解也不是。
7. 20.当在两个顶点之间沿一个方向行驶的成本（重量）与沿相反方向行驶的成本（重量）不同时
